#+TITLE: About the Network
#+DATE:[2021-11-24 Wed 14:52]
#+STARTUP: overview
* Preface
  我一直对于服务器这方面的只是不是很了解，这篇博客慢慢的来了解
* 概念
  服务器是就是我们计算机的一种，性能更加的强大，基本内部结构和我们普通的计算机没有什么基础差别，细节更加的多。（本地的电脑可以作为一个服务器，我同学自己搞博客网站实现了，
  但是肯定不足）
  服务器性能要求比较高，稳定性也是需要比较高。
  #+begin_export html
<!-- more -->
  #+end_export
* 作用
  服务器主要是用来响应终端的服务请求，我们上网就是通过服务器来链接网络，当服务器响应了我们的请求，就是上网成功的时候。（大部分的功能都是服务器完成的）
* 服务器分类
** 物理形态分类
*** 服务器
	放在远程机房的独立计算机。
*** ECS 服务器
	就是现在比较流行的云服务器(Elastic Compute Service)，通常都是自己选 *容量、CPU能力、内存* 所以也是被叫做弹性计算服务器。
*** VPS服务器
	虚拟专用服务器(Virtual Private Server)，即是将一台独立服务器通过虚拟技术分割为若干个虚拟服务器，每个 VPS 可以独立安装系统，拥有独立的 IP，内存，CPU 等是独立的使用的，
	VPS 可以像独立服务器一样重装系统和安装程序等
*** 虚拟主机
	将一台已安装操作系统和安全防范的服务器通过技术手段分割为若干个独立的空间，分配给用户独立使用，解析绑定域名就能够使用。 *虚拟主机无法安装系统和操作软件* ，只能运行网站脚本语言或者
	html 文件，图片以及其他的若干文件。（github.io 博客自定义域名就是这个玩意。）（虚拟主机就是多个用户租用了一台服务器）
** 物理位置分类
*** 国内主机
*** 国外主机
	- 国内主机必须备案，国外主机不需要提交备案资料
	- 国内主机国内快，国外主机一样的的道理
	- 线路：国内主机有线路限制，海外主机没有，国内的主机线路以联通和电信为主，相同的线路访问不存在速度限制，但相互访问会存在问题
* 服务器关键参数指标
  - 操作系统 :: Linux 首推。
  - 支持脚本 :: 根据自己需要网站程序所使用的开发语言选择，支持语言越少的越安全。
  - 空间容量 :: 存放文件的空间大小，一般来说 1-5 G。
  - 主机带宽 :: 主机支持的最大下行访问速度，直接影响网站的访问速度，同时也要考虑一台服务器有多少个网站。
  - 访问流量 :: 对我不太重要，有用及查。
  - 并发量 :: 同一时刻请求访问网站的用户数量。

（ *暂时到这* ）
* http 以及 https 协议
- =http= 协议：不安全，未加密，明文形式在 web 中跑，容易被截取。
- =https= 协议：相对安全，对请求报文和响应报文做加密。
** http 协议
*** http 协议的发展历史
1. http0.9
   - 只有一个 =GET= 命令，没有 header 等描述数据的信息，服务器发送完毕，就关闭 tcp 协议
2. http1.0
   1. 增加了请求命令（GET,POST,HEAD）
   2. status code
   3. 多字符集支持
   4. 权限
   5. 缓存
   6. 内容编码
   7. 多部分发送
	  #+begin_verse
HTTP/1.0 版本的缺点就是无法持续的进行链接，每次 TCP 连接都会释放，如果还要请求其他的资源，那么必须重新建立一个 TCP 连接
但是新建 TCP 连接的成本比较高，三报文握手，所以随着网页资源变多，问题凸显的更加严重
有个方法，可以在请求头上加入一个非标准的 =Connetction= 字段， ~Connection: keep-alive~
这个字段要求不要关闭 TCP 连接，服务器在响应头中会答复这个字段，但是这终究不是一个标准的字段，所以 HTTP/1.1 版本发布
	  #+end_verse
3. http1.1
   1. 增加了请求命令(OPTIONS,PUT,PATCH,DELETE,TRACE,CONNECT)
   2. 一段时间内持续连接
   3. 增加 host
	  #+begin_quote
HTTP/1.1 协议允许复用 TCP 连接，但是在同一个 TCP 中，所有的数据通信都是俺次序进行，服务器只有处理了上一个命令，才会
处理下一个连接的，这个被称为 *队头堵塞* ，可以使用如下方法解决
1. 减少请求数
2. 同时多开持久连接
	  #+end_quote
4. spdy 协议： 谷歌自行研发，主要解决了 http/1.1 效率不高的问题，被当作 https2 的基础，主要特性都被 http2 继承
5. http2
   1. 二进制传输（以前都是 ASCII 文本传输）
   2. 信道复用
   3. 分帧传输
   4. server push
*** HTTP 三次握手
具体的图可以看书《计算机网络 第七版》，关于其中的 ASCII 码，可以查看 [[http://c.biancheng.net/c/ascii/][ASCII]] 表。
1. 第一次握手，发送 =SYN= 报文，传达信息"想要建立连接"
2. 第二次握手，服务器回传 =SYN,ACK 报文= ，传达信息"可以建立连接"
3. 第三次握手，客户端发送 =ACK 报文= ，传达信息"那就建立连接"
   + =SYN (Synchronous Idle)= 同步空闲
   + =ACK (Acknowledge)= 回应，响应
*** HTTP 四次挥手
1. 第一次挥手：客户端和服务端打电话，通话即将结束
2. 第二次挥手：服务端回应通话结束，但是服务器能说话，客户端属于 *半关闭状态*
3. 第三次挥手：服务端还能发送信息，发送完后 ~FIN=1~ 表示想结束通话
4. 第四次挥手：客户端发出 ~ACK=1~ 确认结束
   1. TCP 进行四次挥手：因为数据传送结束之后发出连接释放的通知，等待对方确认之后进入半关闭状态，当另外一端（服务端）没有信息进行传输，
	  则发出连接释放的通知，对方（客户端）确认之后，完全关闭 TCP 连接
*** HTTP 报文
1. 请求报文
   - 请求行、消息报头、请求正文
2. 响应报文
   - 状态行、消息报头、响应正文
3. 消息报头和正文之间有一空行
*** HTTP 状态码
[[https://www.runoob.com/http/http-status-codes.html][http 状态码]]，随用随查
*** 跨域(CORS)
1. 什么是跨域：浏览器的 *同源策略* 限制了跨域请求资源，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），这样浏览器可以访问加载这些资源。
   跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的"预检"请求
这个玩意不太适合现在的我。
1. 可缓存性
   + public 任何都可以
   + private 只有发起浏览器能缓存
   + no-cache 去服务端验证才能发
   + no-slore 彻底不能
   + no-transform 代理服务器不能改动返回内容

** https 协议
*** 对称加密
1. 特点
   1. 加密和解密使用 *相同* 的密钥
   2. 高效，适用于大量数据的加密场景
   3. 算法公开，安全性取决于密钥大小，但是密钥越大效率越低，需要在安全和效率中做权衡
   4. （密文和密钥同时上传发送，截取到了就被破了）
2. 缺点
   1. 算法本身安全，但是使用场景不够安全，因为加密和解密使用的都是同一个密钥。
*** 非对称加密
1. 使用 *匹配的一对密钥* 进行加密和解密，一个叫做公开密钥(public key, 公钥)，一个叫做私有密钥(private key, 私钥)
   1. 公钥其实是私钥生成的
2. *公钥加密的数据只能用对应的私钥解密，同理，私钥加密的数据只能用对应的公钥解密*
3. 算法：RSA、ECC、Elegamal、背包算法、Rabin、D-H等
4. 特点：安全性高
5. 缺点：加密解密比较复杂，效率低，耗时较长
6. 算法概要
   1. 加密：对数据进行加密
   2. 签名：证明数据是谁发的
明天继续（[2021-12-11 Sat 23:08]）
**** 对称加密
浏览器将请求报文和密钥同时通过网络发送给服务器
**** 非对称加密
- 浏览器想要将请求报文加密发给服务器，需要拿到服务器的公钥(服务器自己保留私钥)，服务器通过网络发 *服务器公钥* 给浏览器(也是可能会被截取，用黑客的公钥发给浏览器，如果浏览器用黑客的公钥加密，
那么通过网络传输的时候，黑客截取信息可以通过自己的私钥进行解密，成功获取到了信息，这么来看还是不安全)（预想的）。
- 这时候浏览器需要验证收到的公钥是否是服务器发出来的，这时候搞个第三方验证时候，这个认证机构非常的重要(根认证机构，根认证机构会下分多个认证机构)，服务器把服务器公钥给认证机构，认证机构生成机构公钥和机构私钥（机构公钥默认已经安装到了本机），认证机构使用机构密钥加密服务器上传的 *服务器公钥，服务器域名等其他* ，生成服务器的 *证书*，
服务器保留自己的证书（证书的本质就是服务器的公钥、域名等其他的东西）
- 在正式传输之前，浏览器会请求服务器的证书（本质就是服务器公钥，域名等），这时候就算黑客截取，没有认证机构的公钥也无法解密。
- 即使这样，非对称加密效率低，此时浏览器自己使用对称加密，生成对称加密密钥（会话密钥），这时候效率变高了，用服务器公钥加密浏览器密钥，在发送请求报文之前，发送给服务器，这样效率变高。（服务器
  发送信息给浏览器 -- 接受会话密钥成功）
- 最后就是通过对称加密进行信息传输，加快了效率。
